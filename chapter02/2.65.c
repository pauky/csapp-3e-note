/**
 * 题目要求判断x有奇数个1位则返回1，否则返回0
 * 因为限制了最多12次的运算次数，不然循环32次判断多少位1即可
 * 偶数个1则有偶数个0，如果利用异或，将每一位逐个异或，最终为0，如果奇数个1，则最终结果为1，但需要31次运算
 * 利用分治思想，每次进行一半数量的位级异或，
 * 即16高位与16低位异或，最终得到的16位结果再取8高位与8低位异或，得到8位再取4高位与4低位异或，得到4位再取2高位与2低位异位，得到2位再取1高位与1低位异或
 * 最终返回x的最低位即可
 */

#include <assert.h>

int odd_one(unsigned x)
{
    x ^= x >> 16;
    x ^= x >> 8;
    x ^= x >> 4;
    x ^= x >> 2;
    x ^= x >> 1;
    return x & 0x1;
}

int main()
{
    assert(odd_one(0x101010));
    assert(!odd_one(0x101011));
    return 1;
}